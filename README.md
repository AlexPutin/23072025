# Тестовое задание

## Инструкция по запуску сервера

1. Установите Go: https://go.dev/doc/install
2. Клонируйте репозиторий и перейдите в папку проекта.
3. Установите зависимости:
```
go mod tidy
```
4. Запустите сервер:
```
go run .\cmd\api\main.go
```
5. Сервер будет запущен на указанном в конфиге порту. По умолчанию сервер запускается по адресу http://localhost:8080/

## API

### POST `/api/task`
Создать новую задачу.
- Ответ: JSON с данными задачи.
```json
{
  "id": "500d982f-72dd-4700-8d91-775319d2ea3c",
  "status": "created"
}
```

### GET `/api/task/:id`
Получить информацию о задаче по ID.
- Ответ: JSON с данными задачи.

Как только выполнение задачи завершится ручка вернет статус `"done"` и поместит ссылку на архив в поле `"archive"`
```json
{
  "id": "500d982f-72dd-4700-8d91-775319d2ea3c",
  "status": "done",
  "files": [
    {
      "url": "https://example.com/file.pdf"
    },
    {
      "url": "https://example.com/image1.jpg"
    },
    {
      "url": "https://example.com/image2.jpeg"
    }
  ],
  "archive": "localhost:8080/archive/500d982f-72dd-4700-8d91-775319d2ea3c"
}
```

### POST `/api/task/:id/add_file`
Добавить файл к задаче.
- Тело запроса: `{ "url": "https://example.com/file.pdf" }`
- Ответ: JSON с обновлённой задачей. 

Как только задача заполняется необходимым количеством файлов, то она пускается в обработку и ручка возвращает статус `"processing"`
```json
{
  "id": "500d982f-72dd-4700-8d91-775319d2ea3c",
  "status": "processing",
  "files": [
    {
      "url": "https://example.com/file.pdf"
    },
    {
      "url": "https://example.com/image1.jpg"
    },
    {
      "url": "https://example.com/image2.jpeg"
    }
  ]
}
```

### GET /archive/:id
Скачать архив с файлами задачи.
- Ответ: файл-архив (application/octet-stream).

## Конфигурация (config.yaml)

### server

| Параметр      | Описание                        | Пример     |
|---------------|---------------------------------|------------|
| host          | адрес сервера                   | localhost  |
| port          | порт для запуска сервера        | 8080       |
| idle_timeout  | таймаут простоя сервера         | 60s        |
| read_timeout  | таймаут чтения запроса          | 10s        |
| write_timeout | таймаут записи ответа           | 30s        |

### service

| Параметр           | Описание                                  | Пример                |
|--------------------|-------------------------------------------|-----------------------|
| archive_directory  | папка для хранения архивов                | archives              |
| max_active_tasks   | максимальное количество активных задач    | 3                     |
| max_files_per_task | максимальное количество файлов в задаче   | 3                     |
| allowed_extensions | список разрешённых расширений файлов      | .jpg, .jpeg, .pdf     |


## Комментарии к заданию

Так как определить тип файла по его ссылке не всегда возможно, а в ТЗ указано, что можно указывать расширения допустимых файлов в конфиге, то было принято решение работать только с файлами у которых `url.Path` заканчивается расширением файла. Это позволило проводить валидацию типа на этапе добавления файла в задачу. Способ с проверкой `Content-Type` не рассматриваем, так как не все сервера возвращают MIME-тип. Самый надежный способ это проверка сигнатуры, но он не такой гибкий. Например чтобы проверить JPEG файл нам необходимо открыть соединение и прочитать первые 3 байта, если они равны `FF D8 FF` то все верно. Аналогично и с PDF, если первые 4 байта d в ASCII равны `%PDF`. В этом случае для поддержки разных типов нам необходимо хранить описание сигнатуры каждого типа файла